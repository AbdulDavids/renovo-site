"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useHoverReferenceInteraction = useHoverReferenceInteraction;
var React = _interopRequireWildcard(require("react"));
var _dom = require("@floating-ui/utils/dom");
var _useValueAsRef = require("@base-ui-components/utils/useValueAsRef");
var _useStableCallback = require("@base-ui-components/utils/useStableCallback");
var _utils = require("../utils");
var _createBaseUIEventDetails = require("../../utils/createBaseUIEventDetails");
var _reasons = require("../../utils/reasons");
var _useHover = require("./useHover");
var _getEmptyRootContext = require("../utils/getEmptyRootContext");
var _FloatingTree = require("../components/FloatingTree");
var _useHoverInteractionSharedState = require("./useHoverInteractionSharedState");
function getRestMs(value) {
  if (typeof value === 'function') {
    return value();
  }
  return value;
}

/**
 * Provides hover interactions that should be attached to reference or trigger
 * elements.
 */
function useHoverReferenceInteraction(context, props = {}) {
  const ctx = context ?? (0, _getEmptyRootContext.getEmptyRootContext)();
  const {
    open,
    onOpenChange,
    dataRef,
    elements
  } = ctx;
  const {
    enabled = true,
    delay = 0,
    handleClose = null,
    mouseOnly = false,
    restMs = 0,
    move = true,
    triggerElement = null,
    externalTree,
    isActiveTrigger = true
  } = props;
  const tree = (0, _FloatingTree.useFloatingTree)(externalTree);
  const {
    pointerTypeRef,
    interactedInsideRef,
    handlerRef: closeHandlerRef,
    blockMouseMoveRef,
    performedPointerEventsMutationRef,
    unbindMouseMoveRef,
    restTimeoutPendingRef,
    openChangeTimeout,
    restTimeout,
    handleCloseOptionsRef
  } = (0, _useHoverInteractionSharedState.useHoverInteractionSharedState)(ctx);
  const handleCloseRef = (0, _useValueAsRef.useValueAsRef)(handleClose);
  const delayRef = (0, _useValueAsRef.useValueAsRef)(delay);
  const openRef = (0, _useValueAsRef.useValueAsRef)(open);
  const restMsRef = (0, _useValueAsRef.useValueAsRef)(restMs);
  if (isActiveTrigger) {
    // eslint-disable-next-line no-underscore-dangle
    handleCloseOptionsRef.current = handleCloseRef.current?.__options;
  }
  const isClickLikeOpenEvent = (0, _useStableCallback.useStableCallback)(() => {
    if (interactedInsideRef.current) {
      return true;
    }
    return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;
  });
  const closeWithDelay = React.useCallback((event, runElseBranch = true) => {
    const closeDelay = (0, _useHover.getDelay)(delayRef.current, 'close', pointerTypeRef.current);
    if (closeDelay && !closeHandlerRef.current) {
      openChangeTimeout.start(closeDelay, () => onOpenChange(false, (0, _createBaseUIEventDetails.createChangeEventDetails)(_reasons.REASONS.triggerHover, event)));
    } else if (runElseBranch) {
      openChangeTimeout.clear();
      onOpenChange(false, (0, _createBaseUIEventDetails.createChangeEventDetails)(_reasons.REASONS.triggerHover, event));
    }
  }, [delayRef, closeHandlerRef, onOpenChange, pointerTypeRef, openChangeTimeout]);
  const cleanupMouseMoveHandler = (0, _useStableCallback.useStableCallback)(() => {
    unbindMouseMoveRef.current();
    closeHandlerRef.current = undefined;
  });
  const clearPointerEvents = (0, _useStableCallback.useStableCallback)(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = (0, _utils.getDocument)(elements.floating).body;
      body.style.pointerEvents = '';
      body.removeAttribute(_useHoverInteractionSharedState.safePolygonIdentifier);
      performedPointerEventsMutationRef.current = false;
    }
  });
  const handleScrollMouseLeave = (0, _useStableCallback.useStableCallback)(event => {
    if (isClickLikeOpenEvent()) {
      return;
    }
    if (!dataRef.current.floatingContext) {
      return;
    }
    if (event.relatedTarget && elements.triggers && elements.triggers.includes(event.relatedTarget)) {
      return;
    }
    handleCloseRef.current?.({
      ...dataRef.current.floatingContext,
      tree,
      x: event.clientX,
      y: event.clientY,
      onClose() {
        clearPointerEvents();
        cleanupMouseMoveHandler();
        if (!isClickLikeOpenEvent()) {
          closeWithDelay(event);
        }
      }
    })(event);
  });
  React.useEffect(() => {
    if (!enabled) {
      return undefined;
    }
    const trigger = triggerElement ?? (isActiveTrigger ? elements.domReference : null);
    if (!(0, _dom.isElement)(trigger)) {
      return undefined;
    }
    function onMouseEnter(event) {
      openChangeTimeout.clear();
      blockMouseMoveRef.current = false;
      if (mouseOnly && !(0, _utils.isMouseLikePointerType)(pointerTypeRef.current) || getRestMs(restMsRef.current) > 0 && !(0, _useHover.getDelay)(delayRef.current, 'open')) {
        return;
      }
      const openDelay = (0, _useHover.getDelay)(delayRef.current, 'open', pointerTypeRef.current);
      const triggerNode = event.currentTarget ?? undefined;
      const isOverInactiveTrigger = elements.domReference && triggerNode && !(0, _utils.contains)(elements.domReference, triggerNode);
      if (openDelay) {
        openChangeTimeout.start(openDelay, () => {
          if (!openRef.current) {
            onOpenChange(true, (0, _createBaseUIEventDetails.createChangeEventDetails)(_reasons.REASONS.triggerHover, event, triggerNode));
          }
        });
      } else if (!open || isOverInactiveTrigger) {
        onOpenChange(true, (0, _createBaseUIEventDetails.createChangeEventDetails)(_reasons.REASONS.triggerHover, event, triggerNode));
      }
    }
    function onMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        clearPointerEvents();
        return;
      }
      unbindMouseMoveRef.current();
      const doc = (0, _utils.getDocument)(elements.floating);
      restTimeout.clear();
      restTimeoutPendingRef.current = false;
      if (event.relatedTarget && elements.triggers && elements.triggers.includes(event.relatedTarget)) {
        return;
      }
      if (handleCloseRef.current && dataRef.current.floatingContext) {
        if (!open) {
          openChangeTimeout.clear();
        }
        closeHandlerRef.current = handleCloseRef.current({
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents();
            cleanupMouseMoveHandler();
            if (!isClickLikeOpenEvent()) {
              closeWithDelay(event, true);
            }
          }
        });
        const handler = closeHandlerRef.current;
        doc.addEventListener('mousemove', handler);
        unbindMouseMoveRef.current = () => {
          doc.removeEventListener('mousemove', handler);
        };
        return;
      }
      const shouldClose = pointerTypeRef.current === 'touch' ? !(0, _utils.contains)(elements.floating, event.relatedTarget) : true;
      if (shouldClose) {
        closeWithDelay(event);
      }
    }
    function onScrollMouseLeave(event) {
      handleScrollMouseLeave(event);
    }
    if (open) {
      trigger.addEventListener('mouseleave', onScrollMouseLeave);
    }
    if (move) {
      trigger.addEventListener('mousemove', onMouseEnter, {
        once: true
      });
    }
    trigger.addEventListener('mouseenter', onMouseEnter);
    trigger.addEventListener('mouseleave', onMouseLeave);
    return () => {
      if (open) {
        trigger.removeEventListener('mouseleave', onScrollMouseLeave);
      }
      if (move) {
        trigger.removeEventListener('mousemove', onMouseEnter);
      }
      trigger.removeEventListener('mouseenter', onMouseEnter);
      trigger.removeEventListener('mouseleave', onMouseLeave);
    };
  }, [cleanupMouseMoveHandler, clearPointerEvents, blockMouseMoveRef, dataRef, delayRef, closeWithDelay, elements.domReference, elements.floating, elements.triggers, enabled, handleCloseRef, handleScrollMouseLeave, isActiveTrigger, isClickLikeOpenEvent, mouseOnly, move, onOpenChange, open, openRef, pointerTypeRef, restMsRef, restTimeout, restTimeoutPendingRef, openChangeTimeout, triggerElement, tree, unbindMouseMoveRef, closeHandlerRef]);
  const referenceProps = React.useMemo(() => {
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,
      onMouseMove(event) {
        const {
          nativeEvent
        } = event;
        const trigger = event.currentTarget;
        const isOverInactiveTrigger = elements.domReference && !(0, _utils.contains)(elements.domReference, event.target);
        function handleMouseMove() {
          if (!blockMouseMoveRef.current && (!openRef.current || isOverInactiveTrigger)) {
            onOpenChange(true, (0, _createBaseUIEventDetails.createChangeEventDetails)(_reasons.REASONS.triggerHover, nativeEvent, trigger));
          }
        }
        if (mouseOnly && !(0, _utils.isMouseLikePointerType)(pointerTypeRef.current)) {
          return;
        }
        if (open && !isOverInactiveTrigger || getRestMs(restMsRef.current) === 0) {
          return;
        }
        if (!isOverInactiveTrigger && restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2) {
          return;
        }
        restTimeout.clear();
        if (pointerTypeRef.current === 'touch') {
          handleMouseMove();
        } else if (isOverInactiveTrigger) {
          handleMouseMove();
        } else {
          restTimeoutPendingRef.current = true;
          restTimeout.start(getRestMs(restMsRef.current), handleMouseMove);
        }
      }
    };
  }, [blockMouseMoveRef, elements.domReference, mouseOnly, onOpenChange, open, openRef, pointerTypeRef, restMsRef, restTimeout, restTimeoutPendingRef]);
  return referenceProps;
}