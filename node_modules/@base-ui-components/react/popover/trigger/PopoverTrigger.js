"use strict";
'use client';

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PopoverTrigger = void 0;
var _formatErrorMessage2 = _interopRequireDefault(require("@base-ui-components/utils/formatErrorMessage"));
var React = _interopRequireWildcard(require("react"));
var ReactDOM = _interopRequireWildcard(require("react-dom"));
var _useStableCallback = require("@base-ui-components/utils/useStableCallback");
var _useIsoLayoutEffect = require("@base-ui-components/utils/useIsoLayoutEffect");
var _PopoverRootContext = require("../root/PopoverRootContext");
var _useButton = require("../../use-button/useButton");
var _popupStateMapping = require("../../utils/popupStateMapping");
var _useRenderElement = require("../../utils/useRenderElement");
var _constants = require("../../utils/constants");
var _floatingUiReact = require("../../floating-ui-react");
var _constants2 = require("../utils/constants");
var _useOpenInteractionType = require("../../utils/useOpenInteractionType");
var _useBaseUiId = require("../../utils/useBaseUiId");
var _FocusGuard = require("../../utils/FocusGuard");
var _utils = require("../../floating-ui-react/utils");
var _createBaseUIEventDetails = require("../../utils/createBaseUIEventDetails");
var _reasons = require("../../utils/reasons");
var _popupStoreUtils = require("../../utils/popupStoreUtils");
var _jsxRuntime = require("react/jsx-runtime");
/**
 * A button that opens the popover.
 * Renders a `<button>` element.
 *
 * Documentation: [Base UI Popover](https://base-ui.com/react/components/popover)
 */
const PopoverTrigger = exports.PopoverTrigger = /*#__PURE__*/React.forwardRef(function PopoverTrigger(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled = false,
    nativeButton = true,
    handle,
    payload,
    openOnHover = false,
    delay = _constants2.OPEN_DELAY,
    closeDelay = 0,
    id: idProp,
    ...elementProps
  } = componentProps;
  const rootContext = (0, _PopoverRootContext.usePopoverRootContext)(true);
  const store = handle?.store ?? rootContext?.store;
  if (!store) {
    throw /* FIXME (minify-errors-in-prod): Unminifyable error in production! */new Error(process.env.NODE_ENV !== "production" ? 'Base UI: <Popover.Trigger> must be either used within a <Popover.Root> component or provided with a handle.' : (0, _formatErrorMessage2.default)(74));
  }
  const id = (0, _useBaseUiId.useBaseUiId)(idProp);
  const floatingContext = store.useState('floatingRootContext');
  const open = store.useState('open');
  const openReason = store.useState('openReason');
  const rootActiveTriggerProps = store.useState('activeTriggerProps');
  const rootInactiveTriggerProps = store.useState('inactiveTriggerProps');
  const stickIfOpen = store.useState('stickIfOpen');
  const mounted = store.useState('mounted');
  const activeTrigger = store.useState('activeTriggerElement');
  const positionerElement = store.useState('positionerElement');
  const [triggerElement, setTriggerElement] = React.useState(null);
  const isTriggerActive = activeTrigger === triggerElement;
  const {
    openMethod,
    triggerProps: interactionTypeTriggerProps,
    reset: resetOpenInteractionType
  } = (0, _useOpenInteractionType.useOpenInteractionType)(open);
  (0, _useIsoLayoutEffect.useIsoLayoutEffect)(() => {
    store.set('openMethod', openMethod);
  }, [store, openMethod]);
  React.useEffect(() => {
    if (!mounted) {
      resetOpenInteractionType();
    }
  }, [mounted, resetOpenInteractionType]);
  const hover = (0, _floatingUiReact.useHover)(floatingContext, {
    enabled: floatingContext != null && openOnHover && (openMethod !== 'touch' || openReason !== _reasons.REASONS.triggerPress),
    mouseOnly: true,
    move: false,
    handleClose: (0, _floatingUiReact.safePolygon)(),
    restMs: delay,
    delay: {
      close: closeDelay
    },
    triggerElement
  });
  const click = (0, _floatingUiReact.useClick)(floatingContext, {
    enabled: floatingContext != null,
    stickIfOpen
  });
  const localProps = (0, _floatingUiReact.useInteractions)([click, hover]);
  const registerTrigger = (0, _popupStoreUtils.useTriggerRegistration)(id, store);
  (0, _useIsoLayoutEffect.useIsoLayoutEffect)(() => {
    if (isTriggerActive) {
      store.set('payload', payload);
    }
  }, [isTriggerActive, payload, store]);
  const state = React.useMemo(() => ({
    disabled,
    open: isTriggerActive && open
  }), [disabled, open, isTriggerActive]);
  const {
    getButtonProps,
    buttonRef
  } = (0, _useButton.useButton)({
    disabled,
    native: nativeButton
  });
  const stateAttributesMapping = React.useMemo(() => ({
    open(value) {
      if (value && openReason === _reasons.REASONS.triggerPress) {
        return _popupStateMapping.pressableTriggerOpenStateMapping.open(value);
      }
      return _popupStateMapping.triggerOpenStateMapping.open(value);
    }
  }), [openReason]);
  const element = (0, _useRenderElement.useRenderElement)('button', componentProps, {
    state,
    ref: [buttonRef, forwardedRef, registerTrigger, setTriggerElement],
    props: [localProps.getReferenceProps(), isTriggerActive ? rootActiveTriggerProps : rootInactiveTriggerProps, interactionTypeTriggerProps, {
      [_constants.CLICK_TRIGGER_IDENTIFIER]: '',
      id,
      key: id
    }, elementProps, getButtonProps],
    stateAttributesMapping
  });
  const preFocusGuardRef = React.useRef(null);
  const handlePreFocusGuardFocus = (0, _useStableCallback.useStableCallback)(event => {
    ReactDOM.flushSync(() => {
      store.setOpen(false, (0, _createBaseUIEventDetails.createChangeEventDetails)(_reasons.REASONS.focusOut, event.nativeEvent, event.currentTarget));
    });
    const previousTabbable = (0, _utils.getTabbableBeforeElement)(preFocusGuardRef.current);
    previousTabbable?.focus();
  });
  const handleFocusTargetFocus = (0, _useStableCallback.useStableCallback)(event => {
    if (positionerElement && (0, _utils.isOutsideEvent)(event, positionerElement)) {
      store.context.beforeContentFocusGuardRef.current?.focus();
    } else {
      ReactDOM.flushSync(() => {
        store.setOpen(false, (0, _createBaseUIEventDetails.createChangeEventDetails)(_reasons.REASONS.focusOut, event.nativeEvent, event.currentTarget));
      });
      let nextTabbable = (0, _utils.getTabbableAfterElement)(triggerElement);
      while (nextTabbable !== null && (0, _utils.contains)(positionerElement, nextTabbable) || nextTabbable?.hasAttribute('aria-hidden')) {
        const prevTabbable = nextTabbable;
        nextTabbable = (0, _utils.getNextTabbable)(nextTabbable);
        if (nextTabbable === prevTabbable) {
          break;
        }
      }
      nextTabbable?.focus();
    }
  });
  if (isTriggerActive) {
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(React.Fragment, {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_FocusGuard.FocusGuard, {
        ref: preFocusGuardRef,
        onFocus: handlePreFocusGuardFocus
      }), element, /*#__PURE__*/(0, _jsxRuntime.jsx)(_FocusGuard.FocusGuard, {
        ref: store.context.triggerFocusTargetRef,
        onFocus: handleFocusTargetFocus
      })]
    });
  }
  return element;
});
if (process.env.NODE_ENV !== "production") PopoverTrigger.displayName = "PopoverTrigger";