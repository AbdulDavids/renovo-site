"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PopoverStore = void 0;
var React = _interopRequireWildcard(require("react"));
var ReactDOM = _interopRequireWildcard(require("react-dom"));
var _store = require("@base-ui-components/utils/store");
var _useTimeout = require("@base-ui-components/utils/useTimeout");
var _useRefWithInit = require("@base-ui-components/utils/useRefWithInit");
var _useOnMount = require("@base-ui-components/utils/useOnMount");
var _empty = require("@base-ui-components/utils/empty");
var _getEmptyRootContext = require("../../floating-ui-react/utils/getEmptyRootContext");
var _reasons = require("../../utils/reasons");
var _constants = require("../../utils/constants");
/* eslint-disable react-hooks/rules-of-hooks */

function createInitialState() {
  return {
    open: false,
    mounted: false,
    modal: false,
    activeTriggerId: null,
    positionerElement: null,
    popupElement: null,
    triggers: new Map(),
    instantType: undefined,
    transitionStatus: 'idle',
    openMethod: null,
    openReason: null,
    titleElementId: undefined,
    descriptionElementId: undefined,
    floatingRootContext: (0, _getEmptyRootContext.getEmptyRootContext)(),
    payload: undefined,
    activeTriggerProps: _empty.EMPTY_OBJECT,
    inactiveTriggerProps: _empty.EMPTY_OBJECT,
    popupProps: _empty.EMPTY_OBJECT,
    stickIfOpen: true,
    nested: false
  };
}
const selectors = {
  open: (0, _store.createSelector)(state => state.open),
  mounted: (0, _store.createSelector)(state => state.mounted),
  activeTriggerId: (0, _store.createSelector)(state => state.activeTriggerId),
  activeTriggerElement: (0, _store.createSelector)(state => state.mounted && state.activeTriggerId != null ? state.triggers.get(state.activeTriggerId) ?? null : null),
  positionerElement: (0, _store.createSelector)(state => state.positionerElement),
  popupElement: (0, _store.createSelector)(state => state.popupElement),
  triggers: (0, _store.createSelector)(state => state.triggers),
  instantType: (0, _store.createSelector)(state => state.instantType),
  transitionStatus: (0, _store.createSelector)(state => state.transitionStatus),
  openMethod: (0, _store.createSelector)(state => state.openMethod),
  openReason: (0, _store.createSelector)(state => state.openReason),
  modal: (0, _store.createSelector)(state => state.modal),
  stickIfOpen: (0, _store.createSelector)(state => state.stickIfOpen),
  floatingRootContext: (0, _store.createSelector)(state => state.floatingRootContext),
  titleElementId: (0, _store.createSelector)(state => state.titleElementId),
  descriptionElementId: (0, _store.createSelector)(state => state.descriptionElementId),
  payload: (0, _store.createSelector)(state => state.payload),
  activeTriggerProps: (0, _store.createSelector)(state => state.activeTriggerProps),
  inactiveTriggerProps: (0, _store.createSelector)(state => state.inactiveTriggerProps),
  popupProps: (0, _store.createSelector)(state => state.popupProps)
};
class PopoverStore extends _store.ReactStore {
  constructor(initialState) {
    super({
      ...createInitialState(),
      ...initialState
    }, {
      popupRef: /*#__PURE__*/React.createRef(),
      backdropRef: /*#__PURE__*/React.createRef(),
      internalBackdropRef: /*#__PURE__*/React.createRef(),
      onOpenChange: undefined,
      onOpenChangeComplete: undefined,
      triggerFocusTargetRef: /*#__PURE__*/React.createRef(),
      beforeContentFocusGuardRef: /*#__PURE__*/React.createRef(),
      preventUnmountingRef: {
        current: false
      },
      stickIfOpenTimeout: new _useTimeout.Timeout()
    }, selectors);
  }
  setOpen = (nextOpen, eventDetails) => {
    const isHover = eventDetails.reason === _reasons.REASONS.triggerHover;
    const isKeyboardClick = eventDetails.reason === _reasons.REASONS.triggerPress && eventDetails.event.detail === 0;
    const isDismissClose = !nextOpen && (eventDetails.reason === _reasons.REASONS.escapeKey || eventDetails.reason == null);
    eventDetails.preventUnmountOnClose = () => {
      this.context.preventUnmountingRef.current = true;
    };
    this.context.onOpenChange?.(nextOpen, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    const details = {
      open: nextOpen,
      nativeEvent: eventDetails.event,
      reason: eventDetails.reason,
      nested: this.state.nested,
      triggerElement: eventDetails.trigger
    };
    const floatingEvents = this.state.floatingRootContext.events;
    floatingEvents?.emit('openchange', details);
    const changeState = () => {
      this.set('open', nextOpen);
      if (nextOpen) {
        this.set('openReason', eventDetails.reason ?? null);
      }

      // If a popup is closing, the `trigger` may be null.
      // We want to keep the previous value so that exit animations are played and focus is returned correctly.
      const newTriggerId = eventDetails.trigger?.id ?? null;
      if (newTriggerId || nextOpen) {
        this.set('activeTriggerId', newTriggerId);
      }
    };
    if (isHover) {
      // Only allow "patient" clicks to close the popover if it's open.
      // If they clicked within 500ms of the popover opening, keep it open.
      this.set('stickIfOpen', true);
      this.context.stickIfOpenTimeout.start(_constants.PATIENT_CLICK_THRESHOLD, () => {
        this.set('stickIfOpen', false);
      });
      ReactDOM.flushSync(changeState);
    } else {
      changeState();
    }
    if (isKeyboardClick || isDismissClose) {
      this.set('instantType', isKeyboardClick ? 'click' : 'dismiss');
    } else if (eventDetails.reason === _reasons.REASONS.focusOut) {
      this.set('instantType', 'focus');
    } else {
      this.set('instantType', undefined);
    }
  };
  static useStore(externalStore, initialState) {
    const store = (0, _useRefWithInit.useRefWithInit)(() => {
      return externalStore ?? new PopoverStore(initialState);
    }).current;
    (0, _useOnMount.useOnMount)(store.disposeEffect);
    return store;
  }
  disposeEffect = () => {
    return this.context.stickIfOpenTimeout.disposeEffect();
  };
}
exports.PopoverStore = PopoverStore;