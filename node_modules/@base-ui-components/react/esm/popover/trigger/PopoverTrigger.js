'use client';

import _formatErrorMessage from "@base-ui-components/utils/formatErrorMessage";
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import { useStableCallback } from '@base-ui-components/utils/useStableCallback';
import { useIsoLayoutEffect } from '@base-ui-components/utils/useIsoLayoutEffect';
import { usePopoverRootContext } from "../root/PopoverRootContext.js";
import { useButton } from "../../use-button/useButton.js";
import { triggerOpenStateMapping, pressableTriggerOpenStateMapping } from "../../utils/popupStateMapping.js";
import { useRenderElement } from "../../utils/useRenderElement.js";
import { CLICK_TRIGGER_IDENTIFIER } from "../../utils/constants.js";
import { safePolygon, useClick, useHover, useInteractions } from "../../floating-ui-react/index.js";
import { OPEN_DELAY } from "../utils/constants.js";
import { useOpenInteractionType } from "../../utils/useOpenInteractionType.js";
import { useBaseUiId } from "../../utils/useBaseUiId.js";
import { FocusGuard } from "../../utils/FocusGuard.js";
import { contains, getNextTabbable, getTabbableAfterElement, getTabbableBeforeElement, isOutsideEvent } from "../../floating-ui-react/utils.js";
import { createChangeEventDetails } from "../../utils/createBaseUIEventDetails.js";
import { REASONS } from "../../utils/reasons.js";
import { useTriggerRegistration } from "../../utils/popupStoreUtils.js";

/**
 * A button that opens the popover.
 * Renders a `<button>` element.
 *
 * Documentation: [Base UI Popover](https://base-ui.com/react/components/popover)
 */
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
export const PopoverTrigger = /*#__PURE__*/React.forwardRef(function PopoverTrigger(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled = false,
    nativeButton = true,
    handle,
    payload,
    openOnHover = false,
    delay = OPEN_DELAY,
    closeDelay = 0,
    id: idProp,
    ...elementProps
  } = componentProps;
  const rootContext = usePopoverRootContext(true);
  const store = handle?.store ?? rootContext?.store;
  if (!store) {
    throw new Error(process.env.NODE_ENV !== "production" ? 'Base UI: <Popover.Trigger> must be either used within a <Popover.Root> component or provided with a handle.' : _formatErrorMessage(74));
  }
  const id = useBaseUiId(idProp);
  const floatingContext = store.useState('floatingRootContext');
  const open = store.useState('open');
  const openReason = store.useState('openReason');
  const rootActiveTriggerProps = store.useState('activeTriggerProps');
  const rootInactiveTriggerProps = store.useState('inactiveTriggerProps');
  const stickIfOpen = store.useState('stickIfOpen');
  const mounted = store.useState('mounted');
  const activeTrigger = store.useState('activeTriggerElement');
  const positionerElement = store.useState('positionerElement');
  const [triggerElement, setTriggerElement] = React.useState(null);
  const isTriggerActive = activeTrigger === triggerElement;
  const {
    openMethod,
    triggerProps: interactionTypeTriggerProps,
    reset: resetOpenInteractionType
  } = useOpenInteractionType(open);
  useIsoLayoutEffect(() => {
    store.set('openMethod', openMethod);
  }, [store, openMethod]);
  React.useEffect(() => {
    if (!mounted) {
      resetOpenInteractionType();
    }
  }, [mounted, resetOpenInteractionType]);
  const hover = useHover(floatingContext, {
    enabled: floatingContext != null && openOnHover && (openMethod !== 'touch' || openReason !== REASONS.triggerPress),
    mouseOnly: true,
    move: false,
    handleClose: safePolygon(),
    restMs: delay,
    delay: {
      close: closeDelay
    },
    triggerElement
  });
  const click = useClick(floatingContext, {
    enabled: floatingContext != null,
    stickIfOpen
  });
  const localProps = useInteractions([click, hover]);
  const registerTrigger = useTriggerRegistration(id, store);
  useIsoLayoutEffect(() => {
    if (isTriggerActive) {
      store.set('payload', payload);
    }
  }, [isTriggerActive, payload, store]);
  const state = React.useMemo(() => ({
    disabled,
    open: isTriggerActive && open
  }), [disabled, open, isTriggerActive]);
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton
  });
  const stateAttributesMapping = React.useMemo(() => ({
    open(value) {
      if (value && openReason === REASONS.triggerPress) {
        return pressableTriggerOpenStateMapping.open(value);
      }
      return triggerOpenStateMapping.open(value);
    }
  }), [openReason]);
  const element = useRenderElement('button', componentProps, {
    state,
    ref: [buttonRef, forwardedRef, registerTrigger, setTriggerElement],
    props: [localProps.getReferenceProps(), isTriggerActive ? rootActiveTriggerProps : rootInactiveTriggerProps, interactionTypeTriggerProps, {
      [CLICK_TRIGGER_IDENTIFIER]: '',
      id,
      key: id
    }, elementProps, getButtonProps],
    stateAttributesMapping
  });
  const preFocusGuardRef = React.useRef(null);
  const handlePreFocusGuardFocus = useStableCallback(event => {
    ReactDOM.flushSync(() => {
      store.setOpen(false, createChangeEventDetails(REASONS.focusOut, event.nativeEvent, event.currentTarget));
    });
    const previousTabbable = getTabbableBeforeElement(preFocusGuardRef.current);
    previousTabbable?.focus();
  });
  const handleFocusTargetFocus = useStableCallback(event => {
    if (positionerElement && isOutsideEvent(event, positionerElement)) {
      store.context.beforeContentFocusGuardRef.current?.focus();
    } else {
      ReactDOM.flushSync(() => {
        store.setOpen(false, createChangeEventDetails(REASONS.focusOut, event.nativeEvent, event.currentTarget));
      });
      let nextTabbable = getTabbableAfterElement(triggerElement);
      while (nextTabbable !== null && contains(positionerElement, nextTabbable) || nextTabbable?.hasAttribute('aria-hidden')) {
        const prevTabbable = nextTabbable;
        nextTabbable = getNextTabbable(nextTabbable);
        if (nextTabbable === prevTabbable) {
          break;
        }
      }
      nextTabbable?.focus();
    }
  });
  if (isTriggerActive) {
    return /*#__PURE__*/_jsxs(React.Fragment, {
      children: [/*#__PURE__*/_jsx(FocusGuard, {
        ref: preFocusGuardRef,
        onFocus: handlePreFocusGuardFocus
      }), element, /*#__PURE__*/_jsx(FocusGuard, {
        ref: store.context.triggerFocusTargetRef,
        onFocus: handleFocusTargetFocus
      })]
    });
  }
  return element;
});
if (process.env.NODE_ENV !== "production") PopoverTrigger.displayName = "PopoverTrigger";