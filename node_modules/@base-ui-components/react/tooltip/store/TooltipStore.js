"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TooltipStore = void 0;
var React = _interopRequireWildcard(require("react"));
var ReactDOM = _interopRequireWildcard(require("react-dom"));
var _store = require("@base-ui-components/utils/store");
var _empty = require("@base-ui-components/utils/empty");
var _useRefWithInit = require("@base-ui-components/utils/useRefWithInit");
var _getEmptyRootContext = require("../../floating-ui-react/utils/getEmptyRootContext");
var _reasons = require("../../utils/reasons");
const selectors = {
  open: (0, _store.createSelector)(state => state.open),
  mounted: (0, _store.createSelector)(state => state.mounted),
  disabled: (0, _store.createSelector)(state => state.disabled),
  instantType: (0, _store.createSelector)(state => state.instantType),
  isInstantPhase: (0, _store.createSelector)(state => state.isInstantPhase),
  floatingRootContext: (0, _store.createSelector)(state => state.floatingRootContext),
  trackCursorAxis: (0, _store.createSelector)(state => state.trackCursorAxis),
  transitionStatus: (0, _store.createSelector)(state => state.transitionStatus),
  disableHoverablePopup: (0, _store.createSelector)(state => state.disableHoverablePopup),
  preventUnmountingOnClose: (0, _store.createSelector)(state => state.preventUnmountingOnClose),
  lastOpenChangeReason: (0, _store.createSelector)(state => state.lastOpenChangeReason),
  triggers: (0, _store.createSelector)(state => state.triggers),
  activeTriggerId: (0, _store.createSelector)(state => state.activeTriggerId),
  activeTriggerElement: (0, _store.createSelector)(state => state.mounted && state.activeTriggerId != null ? state.triggers.get(state.activeTriggerId) ?? null : null),
  activeTriggerProps: (0, _store.createSelector)(state => state.activeTriggerProps),
  inactiveTriggerProps: (0, _store.createSelector)(state => state.activeTriggerProps),
  payload: (0, _store.createSelector)(state => state.payload),
  popupProps: (0, _store.createSelector)(state => state.popupProps),
  popupElement: (0, _store.createSelector)(state => state.popupElement),
  positionerElement: (0, _store.createSelector)(state => state.positionerElement)
};
class TooltipStore extends _store.ReactStore {
  constructor(initialState) {
    super({
      ...createInitialState(),
      ...initialState
    }, {
      popupRef: /*#__PURE__*/React.createRef(),
      onOpenChange: undefined,
      onOpenChangeComplete: undefined
    }, selectors);
  }
  setOpen = (nextOpen, eventDetails) => {
    const reason = eventDetails.reason;
    const isHover = reason === _reasons.REASONS.triggerHover;
    const isFocusOpen = nextOpen && reason === _reasons.REASONS.triggerFocus;
    const isDismissClose = !nextOpen && (reason === _reasons.REASONS.triggerPress || reason === _reasons.REASONS.escapeKey);
    eventDetails.preventUnmountOnClose = () => {
      this.set('preventUnmountingOnClose', true);
    };
    this.context.onOpenChange?.(nextOpen, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    const changeState = () => {
      if (isFocusOpen) {
        this.set('instantType', 'focus');
      } else if (isDismissClose) {
        this.set('instantType', 'dismiss');
      } else if (reason === _reasons.REASONS.triggerHover) {
        this.set('instantType', undefined);
      }
      this.update({
        open: nextOpen,
        lastOpenChangeReason: reason
      });
      const newTriggerId = eventDetails.trigger?.id ?? null;
      if (newTriggerId || nextOpen) {
        this.set('activeTriggerId', newTriggerId);
      }
    };
    if (isHover) {
      // If a hover reason is provided, we need to flush the state synchronously. This ensures
      // `node.getAnimations()` knows about the new state.
      ReactDOM.flushSync(changeState);
    } else {
      changeState();
    }
  };
  static useStore(externalStore, initialState) {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    return (0, _useRefWithInit.useRefWithInit)(() => {
      return externalStore ?? new TooltipStore(initialState);
    }).current;
  }
}
exports.TooltipStore = TooltipStore;
function createInitialState() {
  return {
    open: false,
    mounted: false,
    disabled: false,
    instantType: undefined,
    isInstantPhase: true,
    floatingRootContext: (0, _getEmptyRootContext.getEmptyRootContext)(),
    trackCursorAxis: 'none',
    transitionStatus: 'idle',
    disableHoverablePopup: false,
    preventUnmountingOnClose: false,
    lastOpenChangeReason: null,
    triggers: new Map(),
    payload: undefined,
    activeTriggerId: null,
    activeTriggerProps: _empty.EMPTY_OBJECT,
    inactiveTriggerProps: _empty.EMPTY_OBJECT,
    popupProps: _empty.EMPTY_OBJECT,
    popupElement: null,
    positionerElement: null
  };
}